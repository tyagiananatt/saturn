<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>3D Saturn Gesture System</title>

<style>
* {
    box-sizing: border-box;
    touch-action: none;
}

body {
    margin: 0;
    background: #000;
    overflow: hidden;
    font-family: 'Segoe UI', sans-serif;
    width: 100vw;
    height: 100vh;
}

canvas {
    display: block;
    width: 100vw;
    height: 100vh;
}

#ui {
    position: fixed;
    top: 12px;
    left: 12px;
    font-size: 12px;
    color: #00d2ff;
    pointer-events: none;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    text-shadow: 0 0 10px #00d2ff;
    z-index: 10;
}

@media (min-width: 768px) {
    #ui { font-size: 14px; }
}

video { display: none; }
</style>
</head>

<body>
<div id="ui">Status: Loading Celestial Engine...</div>
<video id="video" playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from "three";

/* ------------------ DEVICE CHECK ------------------ */
const isMobile = window.innerWidth < 768;

/* ------------------ SCENE SETUP ------------------ */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
    isMobile ? 75 : 60,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
);
camera.position.z = isMobile ? 18 : 15;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

/* ------------------ PARTICLES ------------------ */
const count = isMobile ? 14000 : 20000;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(count * 3);
const targets = new Float32Array(count * 3);
const colors = new Float32Array(count * 3);

for (let i = 0; i < count; i++) {
    positions[i*3] = (Math.random() - 0.5) * 20;
    positions[i*3+1] = (Math.random() - 0.5) * 20;
    positions[i*3+2] = (Math.random() - 0.5) * 20;
}

geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
    size: isMobile ? 0.04 : 0.035,
    vertexColors: true,
    blending: THREE.AdditiveBlending,
    transparent: true,
    opacity: 0.8
});

const points = new THREE.Points(geometry, material);
scene.add(points);

/* ------------------ SHAPES ------------------ */
function setSphere() {
    for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        const phi = Math.acos(-1 + (2 * i) / count);
        const theta = Math.sqrt(count * Math.PI) * phi;

        targets[i3]   = 5 * Math.cos(theta) * Math.sin(phi);
        targets[i3+1] = 5 * Math.sin(theta) * Math.sin(phi);
        targets[i3+2] = 5 * Math.cos(phi);

        colors[i3] = 0.2;
        colors[i3+1] = 0.6;
        colors[i3+2] = 1.0;
    }
}

function setSaturn() {
    for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        if (i < count * 0.4) {
            const phi = Math.acos(-1 + (2 * i) / (count * 0.4));
            const theta = Math.sqrt(count * 0.4 * Math.PI) * phi;

            targets[i3]   = 3.5 * Math.cos(theta) * Math.sin(phi);
            targets[i3+1] = 3.5 * Math.sin(theta) * Math.sin(phi);
            targets[i3+2] = 3.5 * Math.cos(phi);

            colors[i3] = 1.0;
            colors[i3+1] = 0.8;
            colors[i3+2] = 0.4;
        } else {
            const angle = Math.random() * Math.PI * 2;
            const radius = 5.5 + Math.random() * 4;

            targets[i3]   = radius * Math.cos(angle);
            targets[i3+1] = (Math.random() - 0.5) * 0.2;
            targets[i3+2] = radius * Math.sin(angle);

            colors[i3] = 0.4;
            colors[i3+1] = 0.7;
            colors[i3+2] = 1.0;
        }
    }
}

setSphere();

/* ------------------ HAND TRACKING ------------------ */
const video = document.getElementById("video");
const ui = document.getElementById("ui");

let handX = 0, handY = 0, pinch = 1;

const hands = new Hands({
    locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.6
});

hands.onResults(results => {
    ui.innerText = "Celestial Engine: Active";

    if (results.multiHandLandmarks?.[0]) {
        const lm = results.multiHandLandmarks[0];

        handX = (lm[8].x - 0.5) * (isMobile ? 25 : 30);
        handY = -(lm[8].y - 0.5) * (isMobile ? 18 : 20);

        const dx = lm[4].x - lm[8].x;
        const dy = lm[4].y - lm[8].y;
        pinch = Math.sqrt(dx * dx + dy * dy);

        if (lm[8].y < 0.45) setSaturn();
        else setSphere();
    }
});

const cameraFeed = new Camera(video, {
    onFrame: async () => await hands.send({ image: video }),
    width: isMobile ? 360 : 640,
    height: 480
});

cameraFeed.start();

/* ------------------ ANIMATION ------------------ */
function animate() {
    requestAnimationFrame(animate);

    const pos = geometry.attributes.position.array;
    points.rotation.y += 0.005;
    points.rotation.x = THREE.MathUtils.lerp(points.rotation.x, 0.4, 0.02);

    for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        const speed = pinch < 0.06 ? 0.3 : 0.06;

        const tx = pinch < 0.06 ? handX : targets[i3] + handX;
        const ty = pinch < 0.06 ? handY : targets[i3+1] + handY;
        const tz = pinch < 0.06 ? 0 : targets[i3+2];

        pos[i3]   += (tx - pos[i3]) * speed;
        pos[i3+1] += (ty - pos[i3+1]) * speed;
        pos[i3+2] += (tz - pos[i3+2]) * speed;
    }

    geometry.attributes.position.needsUpdate = true;
    renderer.render(scene, camera);
}

animate();

/* ------------------ RESIZE ------------------ */
function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

window.addEventListener("resize", onResize);
window.addEventListener("orientationchange", onResize);
</script>
</body>
</html>
